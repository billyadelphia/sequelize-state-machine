{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Sequelize state machine\n * Author billyadelphia\n */\n\nimport { Model } from \"sequelize\";\ninterface IPrototype {\n  prototype: any;\n}\n\ntype Hooks = \"beforeSave\" | \"afterSave\";\ninterface states {\n  initial: boolean;\n  final: true;\n}\n\ntype SequelizeModel = Model & IPrototype & string;\nclass StateMachine {\n  states!: Array<Object | string>;\n  field!: \"state\" | string;\n  transition!: any;\n  transitionIsStrict!: boolean;\n\n  constructor() {\n    this.states = [];\n    this.field = \"state\";\n    this.transition = {};\n    this.transitionIsStrict = true;\n  }\n\n  init(SequelizeModel: SequelizeModel): StateMachine {\n    const stateMachine = this;\n    const states = stateMachine.states;\n    const field = stateMachine.field;\n    const transitionIsStrict = stateMachine.transitionIsStrict;\n    const transition = stateMachine.transition;\n    const hooks: Hooks[] = [\"beforeSave\", \"afterSave\"];\n\n    // adding magic method\n    for (const trs of Object.keys(transition)) {\n      SequelizeModel.prototype[trs] = async () => {\n        if (SequelizeModel) {\n          try {\n            let updating: any = {};\n            updating[field] = transition[trs].to;\n            return await SequelizeModel.update(updating);\n          } catch (e) {\n            throw e;\n          }\n        }\n      };\n    }\n\n    for (const hook of hooks) {\n      SequelizeModel.addHook(\n        hook,\n        `StateMachine${capitalize(hook)}`,\n        async (instance: SequelizeModel, options: any) => {\n          try {\n            const dataValue = instance[field];\n\n            if (inStates(states, dataValue)) {\n              if (instance.previous(dataValue) !== dataValue) {\n                let hookValidation = true;\n                let hookFunction = \"after\";\n\n                if (hook === \"beforeSave\") {\n                  if (instance.isNewRecord) {\n                    hookValidation = isInitialState(states, dataValue);\n                  } else {\n                    hookValidation = fromPreviousState(\n                      transition,\n                      dataValue,\n                      instance.previous(dataValue)\n                    );\n                  }\n                  hookFunction = \"before\";\n                }\n\n                if (transitionIsStrict ? hookValidation : true) {\n                  let beforeValidate = true;\n                  if (\n                    typeof instance[`validate${capitalize(dataValue)}`] ===\n                    \"function\"\n                  ) {\n                    beforeValidate = await instance[\n                      `validate${capitalize(instance[field])}`\n                    ]();\n                  }\n                  if (beforeValidate !== false) {\n                    if (\n                      typeof instance[\n                        `${hookFunction}${capitalize(instance[field])}`\n                      ] === \"function\"\n                    ) {\n                      await instance[\n                        `${hookFunction}${capitalize(instance[field])}`\n                      ]();\n                    }\n                  } else {\n                    throw new Error(\n                      `error : validate${capitalize(\n                        instance[field]\n                      )} is invalid`\n                    );\n                  }\n                } else {\n                  throw new Error(`error : incorrect transition validation`);\n                }\n              }\n            } else {\n              throw new Error(\"error : state not found\");\n            }\n          } catch (e) {\n            throw e;\n          }\n        }\n      );\n    }\n\n    return this;\n  }\n\n  addStates(states: Array<Object | string>): StateMachine {\n    if (Array.isArray(states)) {\n      this.states = states;\n      return this;\n    } else {\n      throw new Error(\"states must be an array\");\n    }\n  }\n\n  stateField(field: string) {\n    if (field) {\n      this.field = field;\n    }\n    return this;\n  }\n\n  addTransition(transition: Object) {\n    this.transition = transition;\n    return this;\n  }\n\n  isStrict(bool: boolean) {\n    this.transitionIsStrict = typeof bool === \"boolean\" ? bool : true;\n    return this;\n  }\n}\n\nconst inStates = (states: Array<Object | string>, state: string) => {\n  if (states && states.length) {\n    let correctState = false;\n    for (const status of states) {\n      if (typeof status === \"object\") {\n        if (status[state]) {\n          correctState = true;\n          break;\n        }\n      } else {\n        if (status === state) {\n          correctState = true;\n          break;\n        }\n      }\n    }\n    return correctState;\n  } else {\n    throw new Error(\"states is not an array !\");\n  }\n};\n\nconst fromPreviousState = (\n  transition: Object,\n  state: string,\n  previousState: string\n) => {\n  if (state !== previousState) {\n    if (typeof transition === \"object\") {\n      let isTrue = false;\n      for (const object of Object.keys(transition)) {\n        let transitionData = transition[object];\n        if (transitionData.to === state) {\n          if (typeof transitionData.from === \"string\") {\n            if (transitionData.from === previousState) {\n              isTrue = true;\n              break;\n            } else {\n              isTrue = false;\n            }\n          } else {\n            if (transitionData.from.includes(previousState)) {\n              isTrue = true;\n              break;\n            } else {\n              isTrue = false;\n            }\n          }\n        } else {\n          isTrue = false;\n        }\n      }\n\n      return isTrue;\n    } else {\n      throw new Error(\"transition is not an object\");\n    }\n  } else {\n    return false;\n  }\n};\n\nconst isInitialState = function (\n  states: Array<Object | string>,\n  state: string\n) {\n  if (states && states.length) {\n    let correctState = true;\n    for (const status of states) {\n      if (typeof status === \"object\") {\n        if (status[state]) {\n          if (status[state].initial === false) {\n            correctState = false;\n            break;\n          }\n          if (status[state].initial === true) {\n            correctState = true;\n            break;\n          }\n        } else {\n          correctState = false;\n          break;\n        }\n      } else {\n        correctState = false;\n        break;\n      }\n    }\n    return correctState;\n  } else {\n    throw new Error(\"states is not an array !\");\n  }\n};\n\nconst capitalize = (s: string): string => {\n  if (typeof s !== \"string\") return \"\";\n  return s.charAt(0).toUpperCase() + s.slice(1);\n};\n\nexport default new StateMachine();\n"]}